#!/bin/bash
# the function "round()" was taken from
# http://stempell.com/2009/08/rechnen-in-bash/

#ffmpeg -i v.mp4 -i logo.png -i a.mp3 -filter_complex "[0:v]scale=720:-2,crop=min(500\,min(iw\,ih)):min(500\,min(iw\,ih))[bg];[bg][1:v] overlay=(W-w)/2:(H-h)/2" -pix_fmt yuv420p -map 2:a -shortest o.mp4
#ffmpeg -y -i 1.mpeg -i 2.mpeg -i 3.mpeg -i 4.mpeg -filter_complex '[0:v][1:v][2:v][3:v] concat=n=4:v=1 [v]' -map '[v]' -c:v libx264 -s 1280x720 -aspect 16:9 -q:v 1 -pix_fmt yuv420p o.mp4
#ffmpeg -i i.mp4 -i i.png -filter_complex "[1:v]format=rgba,fade=in:st=1:d=3:alpha=1,fade=out:st=6:d=3:alpha=1 [ovr]; [0][ovr] overlay" -codec:a copy O.mp4
shopt -s extglob

# the round function:
round()
{
  echo $(printf %.$2f $(echo "scale=$2;(((10^$2)*$1)+0.5)/(10^$2)" | bc))
};
usage()
{
  echo "mvi [options...] merge audio with image"
  echo "-a audio file"
  echo "-i image file"
  echo "-c font color"
  echo "-s font size"
  echo "-b background color"
  echo "-l landscape"
  echo "-d duration"
  echo "-n number"
  echo "usage: mvi"
  echo "mvi -a audio       change metadata"
  echo "mvi -a audio -n 2  break into 2 files"
  echo "mvi -i img%02.jpg  images to video"
  echo "mvi -a audio%.mp3  merge audio"
  echo "mvi -a video%.mp4  merge video"
  echo "mvi -a audio -i image -c fontcolor"
  echo ""
  echo ""
  echo "input file format:"
  echo "file '001.jpg'"
  echo "duration 10"
  exit
}
if [ $# -lt 1 ]; then
  usage
fi

while getopts n:r:a:d:i:c:s:b:ol option
do
case "${option}"
in
a) audio=${OPTARG};;
i) image=${OPTARG};;
c) color=${OPTARG};;
s) fontsize=${OPTARG};;
b) bgcolor=${OPTARG};;
r) rate=${OPTARG};;
n) number=${OPTARG};;
d) duration=${OPTARG};;
o) only="true";;
l) landscape="true";;
esac
done

if [ -z "$audio" ]; then
  echo "no audio file"
  usage
fi

afile=$(basename "$audio")
title=${afile%.*}
if [ -z "$image" ]; then
  if [[ "$audio" == *"%"* ]]; then
    audio=${audio//%/*}
    files=($audio)
    echo ${#files[@]}
    f=${files[1]}
    ext="${f##*.}"
    ffmpeg -safe 0 -f concat -i <(for f in $audio; do echo "file '$PWD/$f'"; done) -c copy merged.$ext
    exit
  fi

  if [ -z "$number" ]; then
    DESC=$(date +%s)
    ffmpeg -i "$audio" -metadata --title="$title" -metadata --description="$DESC" -c copy "$DESC-$audio"
  else
    duration=$(ffprobe -i "$audio" -show_entries format=duration -v quiet -of csv="p=0")
    duration=${duration%.*}
    duration=$(((duration+number-1)/number+1))
    ffmpeg -i "$audio" -f segment -segment_time $duration -codec copy -reset_timestamps 1 -segment_start_number 1 "$title-%02d.mp3"
  fi
  exit
fi

if [[ "$image" == *".txt"* ]]; then
  ffmpeg -v error -f concat -safe 0 -i "$image" -i "$audio" -c:v libx264 -c:a aac -pix_fmt yuv420p -crf 23 -r 24 -shortest -y "$title.mp4"
  exit
fi

if [ -z "$color" ]; then
  color="white"
fi

bgcolor=${bgcolor:-black}
#default rate when no change for image
rate=${rate:-1/5}

width=$(ffprobe -v quiet -print_format json -show_streams $image | grep 'coded_width' | grep -Eo '[0-9]+')
#ffmpeg -i a.jpg -vf scale=640:480 b.jpg
height=$(round $width/16*9 0)
chars=$(echo -n $title|wc -m|grep -oE "[0-9]+")
if [ -z "$duration" ]; then
  duration=$(ffprobe -i "$audio" -show_entries format=duration -v quiet -of csv="p=0")
fi
bitrate=$(ffprobe -i "$audio" -show_entries format=bit_rate -v quiet -of csv="p=0")
echo "image width=${width} height=${height}"

audio_option="-acodec copy"
#audio_option="-c:a aac -b:a $bitrate"
audio_option="-c:a aac -b:a $bitrate"
#ffmpeg -r 60 -f image2 -s 1280x720 -i pic%05d.png -i MP3FILE.mp3 -vcodec libx264 -b 4M -vpre normal -acodec copy OUTPUT.mp4 

MIN_FONT_SIZE=20
fontsize=$(round $width/$chars 0)
wwidth=$(echo "$chars*$MIN_FONT_SIZE" | bc -l)

#2160p: 3840x2160 1440p: 2560x1440 1080p: 1920x1080 720p: 1280x720
#480p: 854x480 360p: 640x360 240p: 426x240
#https://stackoverflow.com/questions/30789367/ffmpeg-how-to-convert-vertical-video-with-black-sides-to-video-169-with-blur
land=""
if [ ! -z "$landscape" ]; then
  land=",split[original][copy];[copy]scale=ih*16/9:-1,crop=h=iw*9/16,gblur=sigma=20[blurred];[blurred][original]overlay=(main_w-overlay_w)/2:(main_h-overlay_h)/2"
fi

scale="pad=width=ceil(iw/2)*2:height=ceil(ih/2)*2"
if [[ "$image" == *"%"* ]]; then
  scale="scale=w=$width:h=$height:force_original_aspect_ratio=1,pad=$width:$height:(ow-iw)/2:(oh-ih)/2"
fi

text="${title//%/\\\\\\\\%}"
#drawtext=enable='between(t,12,3*60)'
if [ ! -z "$only" ]; then
  ffmpeg -v error -r $rate -f image2 -loop 1 -i "$image" -i "$audio" -c:v libx264 -tune stillimage $audio_option -pix_fmt yuv420p -vf "$scale$land" -t $duration -shortest "$title.mp4"
else
  # enough space to show text
  if [ "$wwidth" -lt "$width" ]; then
    ffmpeg -v error -r $rate -f image2 -loop 1 -i "$image" -i "$audio" -c:v libx264 -tune stillimage $audio_option -pix_fmt yuv420p -t $duration -shortest -vf "drawtext=text='${text}':fontfile=/Library/Fonts/Arial\ Unicode.ttf:fontsize=${fontsize}:fontcolor=${color}@1:x=(w-text_w)/2:y=h-th-1:box=1:boxcolor=black@0.8:boxborderw=0,$scale" "$title.mp4"
  else
    #crop=floor(iw/2)*2:floor(ih/2)*2 
    fontsize=MIN_FONT_SIZE
    rate=1
    ffmpeg -v error -r $rate -loop 1 -i "$image" -i "$audio" -c:v libx264 -tune stillimage $audio_option -pix_fmt yuv420p -t $duration -shortest -vf "$scale,drawtext=text='${text}':fontfile=/Library/Fonts/Arial\ Unicode.ttf:fontsize=40:fontcolor=white@1:x=w-mod(50*t\, (w+text_w)):y=h-th-1:box=1:boxcolor=black@0.8" "$title.mp4"
  fi
fi
